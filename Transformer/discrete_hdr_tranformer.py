# -*- coding: utf-8 -*-
"""Discrete HDR_Tranformer.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CO-VpFj9eJZlwCftFSFPfp9avTV82gbl
"""

# Machine Learning on Sequences
#
# HDR : Handwritten Digit Sequence Recognition with a transformer network
#
# d'après le tutoriel sur l'utilisation d'un réseau transformer en traduction 
#    https://github.com/tensorflow/text/blob/master/docs/tutorials/transformer.ipynb
#
# dans le cas présent nous changeons les données d'entrées pour qu'elles soient 
# des séquences de colonnes de pixels discrétisées lors d'une étape de clustering
# identique à celle mise en oeuvre pour les HMM semi-continus.
#
# Install the most re version of TensorFlow to use the improved
# masking support for `tf.keras.layers.MultiHeadAttention`.
!apt install --allow-change-held-packages libcudnn8=8.1.0.77-1+cuda11.2
!pip uninstall -y -q tensorflow keras tensorflow-estimator tensorflow-text
!pip install -q tensorflow_datasets
!pip install -q -U tensorflow-text tensorflow
!pip install -U scikit-learn

import logging
import time

from sklearn.cluster import KMeans
import sklearn.cluster

import numpy as np
import matplotlib.pyplot as plt
import pickle

import tensorflow_datasets as tfds
import tensorflow as tf

from tensorflow.keras.callbacks import ModelCheckpoint

from google.colab import drive

TRAIN = True
END_TRAIN = 10800  # 10800 séquences soit 54000 digits
START_VALID = 10800 # soit 1200 séquences soit 60000  digits (10%)
N_EPOCHS = 6
BUFFER_SIZE = 12000 # séquences en MAXIMUM 20000
BATCH_SIZE = 64
MAX_TOKENS = 140 # en entrée = 5 X 28 pixels
LOAD_KMEANS = False # False = compute k-means and stire the codebook
                    # True = Load precomputed codebook
N_CLUSTERS = 150 # nombre de clusters pour la discrétisation des données

START = 10 # Classe début
END = 11   # classe fin

#!pip install tensorflow-text
#import tensorflow-text

###########################################################################
def positional_encoding(length, depth):
  depth = depth/2

  positions = np.arange(length)[:, np.newaxis]     # (seq, 1)
  depths = np.arange(depth)[np.newaxis, :]/depth   # (1, depth)

  angle_rates = 1 / (10000**depths)         # (1, depth)
  angle_rads = positions * angle_rates      # (pos, depth)

  pos_encoding = np.concatenate(
      [np.sin(angle_rads), np.cos(angle_rads)],
      axis=-1) 

  return tf.cast(pos_encoding, dtype=tf.float32)

###########################################################################
class PositionalEmbedding(tf.keras.layers.Layer):
  def __init__(self, vocab_size, d_model):
    super().__init__()
    self.d_model = d_model
    self.embedding = tf.keras.layers.Embedding(vocab_size, d_model, mask_zero=True) 
    self.pos_encoding = positional_encoding(length=2048, depth=d_model)

  def compute_mask(self, *args, **kwargs):
    masque =self.embedding.compute_mask(*args, **kwargs)
    return masque

  def call(self, x):
    length = tf.shape(x)[1]
    x = self.embedding(x)

    # This factor sets the relative scale of the embedding and positonal_encoding.
    x *= tf.math.sqrt(tf.cast(self.d_model, tf.float32))
    x = x + self.pos_encoding[tf.newaxis, :length, :] # newaxis parce qu'on travaille sur un lot
                                                      # (batch_size, length, d_model)
    return x
###########################################################################
class BaseAttention(tf.keras.layers.Layer):
  def __init__(self, **kwargs):
    super().__init__()
    self.mha = tf.keras.layers.MultiHeadAttention(**kwargs)
    self.layernorm = tf.keras.layers.LayerNormalization()
    self.add = tf.keras.layers.Add()
###########################################################################
class CrossAttention(BaseAttention):
  def call(self, x, context):
    attn_output, attn_scores = self.mha(
        query=x,
        key=context,
        value=context,
        return_attention_scores=True)

    # Cache the attention scores for plotting later.
    self.last_attn_scores = attn_scores

    x = self.add([x, attn_output])
    x = self.layernorm(x)

    return x
###########################################################################
class GlobalSelfAttention(BaseAttention):
  def call(self, x):
    attn_output = self.mha(
        query=x,
        value=x,
        key=x)
    x = self.add([x, attn_output])
    x = self.layernorm(x)

    return x
###########################################################################
class CausalSelfAttention(BaseAttention):
  def call(self, x):
    attn_output = self.mha(
        query=x,
        value=x,
        key=x,
        use_causal_mask=True)
    x = self.add([x, attn_output])
    x = self.layernorm(x)

    return x
###########################################################################
class FeedForward(tf.keras.layers.Layer):
  def __init__(self, d_model, dff, dropout_rate=0.1):
    super().__init__()
    self.seq = tf.keras.Sequential([
      tf.keras.layers.Dense(dff, activation='relu'),
      tf.keras.layers.Dense(d_model),
      tf.keras.layers.Dropout(dropout_rate)
    ])
    self.add = tf.keras.layers.Add()
    self.layer_norm = tf.keras.layers.LayerNormalization()

  def call(self, x):
    x = self.add([x, self.seq(x)])
    x = self.layer_norm(x) 
    return x
###########################################################################
class EncoderLayer(tf.keras.layers.Layer):
  def __init__(self,*, d_model, num_heads, dff, dropout_rate=0.1):
    super().__init__()

    self.self_attention = GlobalSelfAttention(
        num_heads=num_heads,
        key_dim=d_model,
        dropout=dropout_rate)

    self.ffn = FeedForward(d_model, dff)

  def call(self, x):
    x = self.self_attention(x)
    x = self.ffn(x)
    return x
###########################################################################
class Encoder(tf.keras.layers.Layer):
  def __init__(self, *, num_layers, d_model, num_heads,
               dff, vocab_size, dropout_rate=0.1):
    super().__init__()

    self.d_model = d_model
    self.num_layers = num_layers


    self.pos_embedding = PositionalEmbedding(
        vocab_size=vocab_size, d_model=d_model)

    self.enc_layers = [
        EncoderLayer(d_model=d_model,
                     num_heads=num_heads,
                     dff=dff,
                     dropout_rate=dropout_rate)
        for _ in range(num_layers)]
    self.dropout = tf.keras.layers.Dropout(dropout_rate)

  def call(self, x):
    # `x` is token-IDs shape: (batch, seq_len)
    x = self.pos_embedding(x)  # Shape `(batch_size, seq_len, d_model)`.

    # Add dropout.
    x = self.dropout(x)

    for i in range(self.num_layers):
      x = self.enc_layers[i](x)

    return x  # Shape `(batch_size, seq_len, d_model)`.
###########################################################################
class DecoderLayer(tf.keras.layers.Layer):
  def __init__(self,
               *,
               d_model,
               num_heads,
               dff,
               dropout_rate=0.1):
    super(DecoderLayer, self).__init__()

    self.causal_self_attention = CausalSelfAttention(
        num_heads=num_heads,
        key_dim=d_model,
        dropout=dropout_rate)

    self.cross_attention = CrossAttention(
        num_heads=num_heads,
        key_dim=d_model,
        dropout=dropout_rate)

    self.ffn = FeedForward(d_model, dff)

  def call(self, x, context):
    x = self.causal_self_attention(x=x)
    x = self.cross_attention(x=x, context=context)

    # Cache the last attention scores for plotting later
    self.last_attn_scores = self.cross_attention.last_attn_scores

    x = self.ffn(x)  # Shape `(batch_size, seq_len, d_model)`.
    return x
###########################################################################
class Decoder(tf.keras.layers.Layer):
  def __init__(self, *, num_layers, d_model, num_heads, dff, vocab_size,
               dropout_rate=0.1):
    super(Decoder, self).__init__()

    self.d_model = d_model
    self.num_layers = num_layers

    self.pos_embedding = PositionalEmbedding(vocab_size=vocab_size,
                                             d_model=d_model)
    self.dropout = tf.keras.layers.Dropout(dropout_rate)
    self.dec_layers = [
        DecoderLayer(d_model=d_model, num_heads=num_heads,
                     dff=dff, dropout_rate=dropout_rate)
        for _ in range(num_layers)]

    self.last_attn_scores = None

  def call(self, x, context):

    # `x` is token-IDs shape (batch, target_seq_len)
    x = self.pos_embedding(x)  # (batch_size, target_seq_len, d_model)

    x = self.dropout(x)

    for i in range(self.num_layers):
      x  = self.dec_layers[i](x, context)

    self.last_attn_scores = self.dec_layers[-1].last_attn_scores

    # The shape of x is (batch_size, target_seq_len, d_model).
    return x
###########################################################################
class Transformer(tf.keras.Model):
  def __init__(self, *, num_layers, d_model, num_heads, dff,
               input_vocab_size, target_vocab_size, dropout_rate=0.1):
    super().__init__()
    self.encoder = Encoder(num_layers=num_layers, d_model=d_model,
                           num_heads=num_heads, dff=dff,
                           vocab_size=input_vocab_size,
                           dropout_rate=dropout_rate)

    self.decoder = Decoder(num_layers=num_layers, d_model=d_model,
                           num_heads=num_heads, dff=dff,
                           vocab_size=target_vocab_size,
                           dropout_rate=dropout_rate)

    self.final_layer = tf.keras.layers.Dense(target_vocab_size)

  def call(self, inputs):
    # To use a Keras model with `.fit` you must pass all your inputs in the
    # first argument.
    context, x  = inputs
    context = self.encoder(context)  # (batch_size, context_len, d_model)
    x = self.decoder(x, context)  # (batch_size, target_len, d_model)

    # Final linear layer output.
    logits = self.final_layer(x)  # (batch_size, target_len, target_vocab_size)

    try:
      # Drop the keras mask, so it doesn't scale the losses/metrics.
      # b/250038731
      del logits._keras_mask
    except AttributeError:
      pass

    # Return the final output and the attention weights.
    return logits
###########################################################################
class CustomSchedule(tf.keras.optimizers.schedules.LearningRateSchedule):
  def __init__(self, d_model, warmup_steps=4000):
    super().__init__()

    self.d_model = d_model
    self.d_model = tf.cast(self.d_model, tf.float32)

    self.warmup_steps = warmup_steps

  def __call__(self, step):
    step = tf.cast(step, dtype=tf.float32)
    arg1 = tf.math.rsqrt(step)
    arg2 = step * (self.warmup_steps ** -1.5)

    return tf.math.rsqrt(self.d_model) * tf.math.minimum(arg1, arg2)
###########################################################################
def masked_loss(label, pred):
  mask = label != 0
  loss_object = tf.keras.losses.SparseCategoricalCrossentropy(
    from_logits=True, reduction='none')
  loss = loss_object(label, pred)

  mask = tf.cast(mask, dtype=loss.dtype)
  loss *= mask

  loss = tf.reduce_sum(loss)/tf.reduce_sum(mask)
  return loss

###########################################################################
def masked_accuracy(label, pred):
  pred = tf.argmax(pred, axis=2)
  label = tf.cast(label, pred.dtype)
  match = label == pred

  mask = label != 0

  match = match & mask

  match = tf.cast(match, dtype=tf.float32)
  mask = tf.cast(mask, dtype=tf.float32)
  return tf.reduce_sum(match)/tf.reduce_sum(mask)

###########################################################################
# pour notre problème de reconnaissance de séquences de digits
def prepare_batch(input, output):
    
  input = input[:, :MAX_TOKENS]    
  input = input.to_tensor()        # Convert to 0-padded dense Tensor
  output =output[:, :MAX_TOKENS]
  output_input = output[:, :-1].to_tensor()  # Drop the [END] tokens
  output_labels = output[:, 1:].to_tensor()   # Drop the [START] tokens
   
  return (input, output_input), output_labels

###########################################################################
# on utilise cette méthode sans modification 
# les batchs aléatoires seront préparés à l'avance selon les capacités 
# de la machine (AUTOTUNE) 
def make_batches(ds):
  return (
      ds
      .shuffle(BUFFER_SIZE)
      .batch(BATCH_SIZE)
      .map(prepare_batch, tf.data.AUTOTUNE)
      .prefetch(buffer_size=tf.data.AUTOTUNE))

###########################################################################
# charge les séquences de digit minist difficile
# et construit les deux objets tf.dataset de train et valid
# 
def load_train_mnist_sequences(end_train = 1000,start_valid = 11700):
  # montage de votre partition drive
  drive.mount('/content/drive',force_remount=True)
  #!mkdir -p drive
  #!ls drive/MyDrive

  # on charge le fichier des dataset des séquences de train et de test
  # qu'on a placé à la racine de notre répertoire Drive
  pkl_file = open('drive/MyDrive/MNIST_5digitsDifficile.pkl', 'rb') 
  x_train,y_train, x_test,y_test = pickle.load(pkl_file) 
  pkl_file.close()

  #l_seq_digits = 5
  D = 28 # 28 X 28
  n_classes = 10 
  N_seq_train = len(y_train)
    
  END_TRAIN = end_train     # 10% des 12000 séquences
  START_VALID = start_valid #300 séquence en validation

  # discretize the test data predicting the closest cluster

  N_train = 4000 # nombre séquences de 5 digits pour le clustering k-means
  file_name = "Codebook_"+str(N_CLUSTERS)+"_"+str(int(N_train*5))
  if not LOAD_KMEANS:
    print('Compute codebook '+str(N_CLUSTERS)+" clusters, "+str(int(N_train * 5))+" digits")
    train = x_train[0]
    for n in range(1,N_train):
      train = np.concatenate((train, x_train[n]),axis=0)

    kmeans = KMeans(N_CLUSTERS, random_state=0).fit(train)
    model_file = open('drive/MyDrive/'+file_name,'wb')
    pickle.dump(kmeans,model_file)
    model_file.close() 
    print('dumped codebook ',file_name,'...')
  else:
    print("Loading codebook: n_cluster =",N_CLUSTERS,"N_train = ",N_train)
    model_file = open('drive/MyDrive/'+file_name,'rb')
    kmeans = pickle.load(model_file)
    model_file.close()
    
  # tenseur en lambaux : données de taille variable
  Train_data = tf.ragged.stack([tf.convert_to_tensor(kmeans.predict(arr)) for arr in x_train[:END_TRAIN]], axis=0)
  Valid_data = tf.ragged.stack([tf.convert_to_tensor(kmeans.predict(arr)) for arr in x_train[START_VALID:]], axis=0)

  # transformé en dataset
  # les images d'abord...
  train_data = tf.data.Dataset.from_tensor_slices(Train_data)
  valid_data = tf.data.Dataset.from_tensor_slices(Valid_data)

  # les labels ensuite
  # on ajoute le laber START et END  
  y_train =[np.asarray([START]+[yy[0] for yy in y]+[END]) for y in y_train]

  Train_labels = tf.ragged.stack([tf.convert_to_tensor(arr) for arr in y_train[:END_TRAIN]], axis=0)
  train_labels = tf.data.Dataset.from_tensor_slices(Train_labels)

  Valid_labels = tf.ragged.stack([tf.convert_to_tensor(arr) for arr in y_train[START_VALID:]], axis=0)
  valid_labels = tf.data.Dataset.from_tensor_slices(Valid_labels)

  # On a crée la structure train_dataset associant séquences d'entrée et séquences de sortie (les labels)
  # Ici on devient conforme au format du tutoriel  
  train_dataset = tf.data.Dataset.zip((train_data, train_labels))
  valid_dataset = tf.data.Dataset.zip((valid_data, valid_labels))

  Test_liste = [tf.convert_to_tensor(kmeans.predict(arr),dtype=tf.int64) for arr in x_test]
  # on reformate les labels de test également mais sans mettre les tokens début et fin
  # le token début est mis automatiquement dans le reconnaisseur
  y_test =[np.asarray([yy[0] for yy in y]) for y in y_test]

  return train_dataset, valid_dataset, Test_liste, y_test, x_test

####################################################################################
class ReconnaisseurSequence(tf.Module):
  def __init__(self, transformer):
    self.transformer = transformer

  def __call__(self, input, max_length=MAX_TOKENS):
    # l'entrée est la séquence de colonnes de pixels discrétisée au format Ragged tensor
    
    encoder_input = input[tf.newaxis]
    #On crée les tokens START et END au format 
    # <class 'tensorflow.python.framework.ops.EagerTensor'>
    start = tf.constant(START,dtype=tf.int64)[tf.newaxis]
    end = tf.constant(END,dtype=tf.int64)[tf.newaxis]

    # un déclare tableau de tenseurs dans lequel seront seauvergardées les sorties précédentes 
    # `tf.TensorArray` is required here (instead of a Python list), so that the
    # dynamic-loop can be traced by `tf.function`.
    output_array = tf.TensorArray(dtype=tf.int64, size=0, dynamic_size=True)
    output_array = output_array.write(0, start)

    for i in tf.range(max_length):
      output = tf.transpose(output_array.stack())
      predictions = self.transformer([encoder_input, output], training=False)

      # Select the last token from the `seq_len` dimension.
      predictions = predictions[:, -1:, :]  # Shape `(batch_size, 1, vocab_size)`.
      predicted_id = tf.argmax(predictions, axis=-1)

      # Concatenate the `predicted_id` to the output which is given to the
      # decoder as its input.
      output_array = output_array.write(i+1, predicted_id[0])

      if predicted_id == end:
        break

    # on prepare les sorties précédentes pour construire le tenseur output qu'on 
    # va ramener à l'éntrée
    output = tf.transpose(output_array.stack())

    # `tf.function` prevents us from using the attention_weights that were
    # calculated on the last iteration of the loop.
    # So, recalculate them outside the loop.
    self.transformer([encoder_input, output[:,:-1]], training=False)
    attention_weights = self.transformer.decoder.last_attn_scores

    return output, attention_weights
##############################################################################
class ExportReconnaisseur(tf.Module):
  def __init__(self, reconnaisseur):
    self.reconnaisseur = reconnaisseur

  @tf.function(input_signature=[tf.TensorSpec(shape=[None],dtype=tf.int64)])
  def __call__(self, input):
    (output, attention_weights) = self.reconnaisseur(input, max_length=MAX_TOKENS)

    return output, attention_weights

##############################################################################
if __name__ == '__main__':
  # nom du fichier de sauvegarde du modèle entrainé
  model_name = "DigitSeqTransformer.tf"
  dir_name = 'drive/MyDrive/'

  train_dataset, valid_dataset, Test_liste, label_test,images_test = load_train_mnist_sequences(end_train = END_TRAIN,start_valid=START_VALID)

  if TRAIN:
    # Create training and validation set batches.
    train_batches = make_batches(train_dataset)
    val_batches = make_batches(valid_dataset)

    ###########################################################
    # déclaration du transformer 
    num_layers = 4     # nb de couches transformer
    d_model = 64       # taille de l'embedding 
    dff = 64           # taille de la couche complèteement connectée de chaque transformer
    num_heads = 4      # nombre de têtes
    dropout_rate = 0.1

    # on déclare le transformer
    my_digit_transformer = Transformer(
        num_layers=num_layers,
        d_model=d_model,
        num_heads=num_heads,
        dff=dff,
        input_vocab_size = N_CLUSTERS, # cas d'une séquence d'entrée discrète
        target_vocab_size = 12,        # 12 symboles 10 + START et  END
        dropout_rate=dropout_rate)
    
    learning_rate = CustomSchedule(d_model)

    optimizer = tf.keras.optimizers.Adam(learning_rate, beta_1=0.9, beta_2=0.98, epsilon=1e-9)

    my_digit_transformer.compile(
        loss=masked_loss,
        optimizer=optimizer,
        metrics=[masked_accuracy])
    
    my_digit_transformer.fit(train_batches,
                    epochs = N_EPOCHS,
                    validation_data=val_batches)
  
    ###############################################################################
    # instanciation du reconnaisseur
    mon_reconnaisseur = ReconnaisseurSequence(my_digit_transformer)
    # export du reconaisseur : crée une classe pour la sauvegarde et le chargement
    mon_reconnaisseur = ExportReconnaisseur(mon_reconnaisseur)
    tf.saved_model.save(mon_reconnaisseur,dir_name+model_name)
    print("Reconnaisseur sauvegardé : "+model_name)
    print("FIN DE L'APPRENTISSAGE")

  else: 
    reconnaisseur_charge = tf.saved_model.load(dir_name+model_name)
    print("Reconnaisseur chargé : "+model_name) 

    taille_test = 10
    for i in range(taille_test):  
      # chaque input de test_liste est un tenseur 
      plt.imshow(np.flip(images_test[i].T,axis=0), cmap='gray')
      plt.show()
      print("x_test",Test_liste[i])
      output, attention_weights = reconnaisseur_charge(Test_liste[i])
      print("séquence reconnue :",output.numpy())
      print("label             :",label_test[i])

"""# Nouvelle section

# Nouvelle section
"""
